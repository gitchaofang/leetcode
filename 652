class Solution {
public:
    std::string dfs(TreeNode* root, std::unordered_map<std::string,int>& m,std::vector<TreeNode*>& res){
        if(!root) return " ";
        std::string left = dfs(root -> left,m,res);
        std::string right = dfs(root -> right,m,res);
        std::string comb = std::to_string(root -> val) +'-'+left+'-'+right;
        if(m.find(comb) != m.end()){
            if(m[comb] == 0) res.push_back(root);
            m[comb] = 1;
        }
        else m[comb] = 0;
        return comb;
        
    }
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        std::unordered_map<std::string,int>m;
        std::vector<TreeNode*> res;
        dfs(root,m,res);
        return res;
    }
};
